# SQL语句的执行过程

[01 | 基础架构：一条SQL查询语句是如何执行的？](https://time.geekbang.org/column/article/115537)

---

[TOC]



## server层

Server 层 = 连接器、查询缓存、分析器、优化器、执行器等

不同的存储引擎**共用**一个Server 层，Server 层相当于一个数据库的**实例**

- 涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等）

- 所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等

### 建立连接

**连接器**负责跟客户端建立连接、获取权限、维持、管理连接

```
mysql -h$ip -P$port -u$user -p
```

- 虽然密码也可以直接跟在 -p 后面写在命令行中，但这样可能会导致你的密码泄露
- -h -P 指定了服务器端，-u -p 指定了客户端

#### 长连接 VS 短连接

- 长连接
  - 对于持续的请求，一直使用同一个连接
  - 建立连接的过程比较复杂，所以尽量使用长连接
  - ✖️占内存大。 MySQL 临时占用的内存是存放在连接里面的，只有连接断开的时候才释放
    内存占用太大，可能会被被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了

- 短连接
  - 执行完很少的几次查询就断开连接，下次查询再重新建立一个

❓长连接占用内存过大怎么办

1.  定期断开长连接。使用一段时间，或者执行过一个占用内存的大查询后，断开连接，之后再重连
2. 对于 MySQL 5.7 以上的版本，可以在大操作后，执行` mysql_reset_connection `初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态

### 查询缓存

（注意：MySQL 8.0 版本将查询缓存的整块功能删掉了）

之前执行过的语句及其结果会以 key-value 的形式，缓存在内存中。其中key 是查询的语句，value 是查询的结果
如果查询能够直接匹配 key，那么 value 就会被直接返回给客户端，不再进入后面的执行阶段

✖️只要有一个对表的更新操作，这个表上所有的查询缓存都会被清空
对于更新压力大的数据库来说，查询缓存的命中率会非常低
除非你的业务就是有一张静态表（系统配置表），那才适合使用查询缓存

设置：将参数 `query_cache_type` 设置成 DEMAND，表示不使用查询缓存
用` SQL_CACHE `显式指定，表示使用查询缓存

```mysql
select SQL_CACHE * from T where ID=10;
```

### 分析器

1. 词法分析：MySQL 需要识别出输入的字符串分别是什么，代表什么。比如从你输入的 "select" 这个关键字识别出这是一个查询语句。把字符串 “T” 识别成 “表名 T” ，把字符串 “ID” 识别成 “列 ID”
2. 语法分析：判断输入语句是否满足SQL语法

经过了分析器，MySQL 就知道你要**做什么**了

### 优化器

优化器是在表里面有多个索引的时候，决定使用哪个索引
或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序

```mysql
select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;
```

- 先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20
- 先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10

 这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案

通过优化器，MySQL知道了该**怎么做**

### 执行器

1. 执行前，先判断一下有没有执行查询的权限，如果有就打开表
2. 打开表的时候，执行器就会根据表的存储引擎定义，去使用它提供的接口

数据库的慢查询日志中，` rows_examined `字段表示这个语句执行过程中扫描了多少行